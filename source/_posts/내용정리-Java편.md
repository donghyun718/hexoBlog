---
title: 내용정리-Java편
date: 2019-07-09 17:54:12
tags:
---
# 내용정리 - JAVA편

### JAVA란
자바는 가상머신(JVM)을 사용하여, 운영체제와는 독립적으로 동작
-> 어느 운영체제에서나 같은 형태로 실행됨

### JAVA 특징
1) 객체지향
객체지향은 모든 것은 객체간의 상호작용에 의해 이루어진다는 개념하에 모든 것을 객체로 정의하여 유지보수성, 확장성 그리고 재사용성을 증가시켜줌
    - 추상화 : 현상에 존재하는 객체의 주요특징 추출
    - 캡슐화 : 하나의 클래스 안에 데이터와 기능을 담아 정의하고 중요한 데이터나 복잡한 기능은 숨기고 외부에 필요한 기능만 공개
    - 상속 : 객체 정의 시 기존에 존재하는 객체의 속성과 기능을 상속받아 정의
    - 다형성 : 같은 타입 또는 같은 기능의 호출로 다양한 효과를 가져오는 것

2) 플랫폼에 독립적

3) 메모리 관리의 어려움과 복잡성을 해결하여 쉽게 접근이 가능

4) 분산 프로그래밍 지원

5) 멀티스레드
thread API를 제공함으로써 운영체제에 종속적이지 않은 독립적 설계와 JVM에 의해 스케줄링이 되도록 구현

### 자바 프로그래밍
1) 자바 컴파일러
자바 컴파일러는 자바 소스 코드를 자바 가상머신이 이해할 수 있는 바이트 코드로 변환
.java -> .class

2) 자바 바이트 코드
자바 바이트 코드는 JVM이 이해할 수 있는 언어로 변환된 소스코드

3) JVM
자바 바이트 코드를 실행시키기 위한 가상의 기계
자바로 작성된 모든 프로그램은 JVM에서만 실행
하드웨어 - OS - JVM - 자바 프로그램
자바 프로그램과 달리 JVM은 운영체제에 종속적이어서 각 운영체제에 맞는 JVM을 설치해야 됨

### 구성
-   자바 인터프리터
: 자바 컴파일러에 의해 변환된 자바 바이트 코드를 읽고 해석하는 역할
-   클래스 로더
: 동적으로 클래스를 로딩해주는 역할
-   JIT 컴파일러
: 자바 컴파일러가 생성한 바이트 코드를 런타임에 바로 기계어로 변환하는 역할
-   가비지 컬렉터
: 개발자가 메모리 관리하지 않아도 사용하지 않는 메모리를 자동으로 회수하는 역할

### 메모리 구조
자바 프로그램이 실행되면 JVM은 운영체제로부터 필요한 메모리를 할당받음
-   클래스 로더
저장장치에 있는 class 파일을 메모리로 읽어오는 역할
-   메소드 영역
클래스에 대한 정보와 함께 클래스 변수가 저정되는 영역
JVM은 자바프로그램에서 특정 클래스가 사용되면 해당 클래스의 클래스파일을 읽어 메소드 영역에 저장
-   힙 영역
모든 인스턴스 변수가 저장
JVM은 new 키워드를 사용하여 인스턴스가 생성되면, 해당 인스턴스의 정보를 힙에 저장
낮은 주소에서 높은 주소 방향으로 할당
-   스택 영역
자바 프로그램에서 메소드가 호출될 때 메소드의 스택 프레임이 저장되는 영역
메소드가 호출되면 지역변수와 매개변수를 스택영역에 저장.
메소드 호출과 함께 할당되며 완료시 소멸
스택 영역은 메모리의 높은 주소에서 낮은 주소 방향으로 할당

### 클래스
1) 클래스 개념
    - 객체 지향 프로그래밍(OOP)
객체의 상태와 행동을 구체화하는 형태의 프로그래밍

    - 클래스
객체를 정의하는 설계도
필드 : 객체의 상태(변수)
메소드 : 객체의 행동(메소드)

    - 인스턴스
메모리에 할당된 객체
하나의 클래스로부터 여러 개의 인스턴스 생성 가능
인스턴스는 독립된 메모리 공간에 자신만의 필드를 갖지만 클래스의 모든 메소드는 모든 인스턴스가 공유


2) 클래스 구성
```java
modifiers class class_name{
    modifiers data_type attribute_identifier;
    modifiers class_identifier;
    modifiers return_type method_identifier(arguments){
        method_code_block
    }
}
```
#### 생성자
-   자바는 객체 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 생성자 메소드를 제공
-   리턴 타입이 없고 클래스 이름과 같음
-   생성자가 정의되지 않았을 경우, 기본 생성자가 컴파일러에 의해 삽입
-   생성자가 있을경우 기본 생성자는 컴파일러가 삽입하지 않으므로 기본생성자도 정의해주는 것이 좋음

1) 생성자 오버로딩
파라미터가 다른 형태로 생성자를 정의할 수 있다.

2) 메소드
오버로딩으로 같은 이름의 method를 정의할 수 있다.
    - 멤버 변수
: heap에 생성, class내 정의되는 변수
    - 지역 변수
: 메소드나 생성자 내에 정의되는 변수, stack에 생성

    - 오버로딩
: 같거나 비슷한 일을 하는 메서드 구현시 이름을 같게 한다.
      - 메소드 이름이 같다.
      - 매개변수 개수 또는 타입이 다르다.
      - 반환타입은 상관없다.

### 접근 제한자
-   private :  같은 클래스 내에서만 사용
-   default : 같은 클래스, 패키지 내에서만 사용
-   protected : 패키지가 다르면 사용 불가, 하지만 상속 받으면 가능
-   public : 어디서나 사용 가능

### 사용 제한자
-   static : 메소드,  필드, 초기화 블록  
프로그램 시작시 최초에 단 한번만 생성되고 초기화  
인스턴스를 생성하지 않고 바로 사용  
해당 클래스의 모든 인스턴스가 공유  

-   final : 클래스, 메소드, 멤버변수, 지역변수  
변수에 사용하면 값을 변경할 수 없는 상수가 되고  
클래스에 사용하면 다른 클래스가 상속받을 수 없게 됨  
메소드에 사용하면 해당 메소드는 오버라이딩을 통한 재정의를 할 수 없게 됨  

-   abstarct : 클래스, 메소드  
선언부만 있고 구현부가 없는 메소드를 추상 메소드라 함  
abstract 제어자를 붙여야 함  
하나 이상의 추상 메소드가 포함하고 있는 추상 클래스도 abstract 제어자를 붙여야 한다.  

클래스에 final과 abstract 같이 사용X  
메소드에 static과 abstract 같이 사용X  
메소드에 private과 abstract 같이 사용X  
메소드에 private과 final 같이 사용할 필요X  

#### 클래스 멤버
필드
-   클래스 변수
: 인스턴스를 생성하지 않고도 바로 사용할 수 있는 클래스 변수를 공유변수라고도 함
-   인스턴스 변수
-   지역 변수

```java
class Animal{
      static int age; // 클래스 변수
      String name;  // 인스턴스 변수
      void eat(){
            int amout = 10; // 지역 변수
      }
}
```

### Encapsulation
#### 캡슐화  
클래스 필드는 관련 메소드와 함께 묶여 있다는 개념. 필드가 직접적으로 조작 되지 않도록 하는 것.
-   데이터 구조와 데이터를 다루는 방법을 결함시켜 묶는 것.

#### 은닉화  
다른 컴포넌트(클래스, 인스턴스 등)로 부터 내가 가진 정보를 숨기는 것.  
ex) private 접근자

캡슐화는 은닉화 - private 접근자를 사용하여 필드를 숨긴뒤, 메소드를 통해서만 해당 필드에 접근하도록 함으로써 달성 가능.

### Inheritance  
기존 클래스에 기능을 추가하거나 재정의 하는 것을 의미
-   Generalization
: 추출된 class의 공통적인 특성을 모아 super class로 정의
-   Specialization
: 비슷한 속성과 기능을 가진 class를 상속 받아 새로운 class 정의

#### 상속의 장점
1) 기존 클래스 재활용
2) 자식 클래스 설계시 중복되는 멤버를 부모 클래스에 작성해 놓으면 자식 클래스는 해당 멤버를 구성하지 않아도 됨
3) 클래스 간 계층적 관계 구성으로 다형성의 문법적 토대 마련

-   부모 클래스의 private, default로 설정된 멤버는 자식클래스에서 상속 받지만 접근 불가
-   속성이나 기능을 선택적으로 상속 불가
-   상속 받은 기능 중 수정을 원하는 기능은 오버라이딩할 수 있고 필요한 속성이나 기능 추가하여 작성 가능

#### 메소드 오버라이딩
자식 클래스의 오버라이딩 되는 메소드
1) 메소드 이름, 리턴 타입, 파라미터는 같고
2) 접근 제한자는 같거나 보다 넓어야 한다.

#### 오버라이딩 vs 오버로딩
**공통점**
-   메소드 정의시 사용되는 기법
-   메소드 이름 같게 정의
-   사용 편리성
-   다형성 효과

**오버로딩**
-   하나의 클래스나, 상속받은 클래스 내에 같거나 비슷한 기능 메서드의 이름 같게 해 편리성 추구
-   메서드 이름은 같고 파라미터는 다르다.



### Polymorphism
#### 객체 다형성  
같은 타입의 변수가 다양한 형태의 객체를 참고
-   자식 객체 생성시 부모도 같이 생성되기 때문에 메모리에 존재하는 부모 타입으로 변수 선언 가능
#### 메소드 다향성  
같은 클래스 타입의 같은 메소드 호출시 그 기능이 다양하게 처리
-   오버라이딩 여부를 확인하고 생성된 객체의 상속 관계에서 마지막 오버라이딩된 메서드 호출

#### 레퍼런스 타입 형변환
1) 자동 형변환  
: 자식 객체 내에는 부모 객체가 같이 있어 부모타입으로 레퍼런스 할 수 있다
    - 부모 객체의 member만 사용 가능
    - 메소드는 부모가 가지고 있는지 체크하고 오버라이딩된 메소드를 행
    - 자식이 추가한 메소드는 사용 불가

2) 명시적 형변환  
원래타입인 자식 객체 타입으로 변경하고자 할 경우에 명시적 형변환 수행

#### 상속의 장점
-   재사용성
-   일관성
-   유지보수성
-   명세서 역할
-   다형성

#### 상속의 단점
-   지나친 상속은 복잡성 증가
-   지나친 상속은 JVM 관리 부하
-   성능 저하


### Interface
-   상수와 구현되지 않은 메서드로 구성
-   특별히 정의하지 않아도 컴파일 시, 아래 제한자가 추가
    -   `public static final` 제한자가 상수 앞에 붙는다.
    -   `public abstract` 제한자가 메서드 앞에 붙는다.

#### 인터페이스 특징
-   인터페이스는 객체 생성할 수 없다.
-   인터페이스를 상속받은 자식 클래스는 모든 메소드를 구현해야한다.
-   상속한 클래스들의 명세서 역할을 한다.
-   자식 클래스는 인터페이스를 다중 상속받을 수 있다.

### Exception
1) Exception : 프로그램 처리 도중 기대되지 않는 상황
2) Error : 치명적인 오류

#### Error
-   치명적 오류로 SW적 복구 불가능
-   uncheked exception
-   Complier가 체크하지 않음

#### Exception
-   예외가 발생할지 모르는 상황 체크(Compiler)
-   예외가 발생하더라고 프로그램 중단하지 않고 복구하여 지속적으로 실행

##### Checked - RuntimeException 제외한 모든 Exception
-   예기치 못한 경미한 오류
-   오류로 프로그램 중단되는 걸 막기 위해, 컴파일러가 체크하여 복구코드를 구현하도록 함

##### Unchecked - Error, RuntimeException
-   Error : 복구 불가능으로 컴파일러가 체크하지 않는다.
-   RuntimeException : 코드 작성이 잘못된 오류로 컴파일시 체크되지 않고 실행시 오류 발생

#### Exception Handler
1) ```try-catch``` 블록
2) 여러 가지 예외 발생할 경우 ```catch``` 블록 여러 개 정의
3) 예외 발생 여부와 관계없이 꼭 수행해야 하는 문장은 ```finally```에 구현
4) ```catch```블록이 없으면 예외 발생시 프로그램 중단
5) ```throws exception``` 선언은 예외를 처리하지 않고 호출한 메서드에게 예외처리를 넘김

### 멀티스레드
-   프로세스 : 개별적으로 동작하는 프로그램
-   스레드 : 프로세스를 구성하는 작은 실행 단위
-   멀티프로세스 : 동시에 여러 개의 프로세스를 실행하는 것
-   멀티스레드 : 하나의 프로세스에서 여러 개의 스레드가 동시에 동작하는 것

#### 멀티 스레드 프로그래밍 장/단점
-   장점
    -   CPU 사용률 향상
    -   작업 분리로 응답성 향상
    -   자원공유로 효율성 증대
-   단점
    -   컨텍스트 스위칭 과정에 별도의 비용이 발생
    -   제어의 어려움

#### 스레드 생성  
1) **Runnable**  
Runnable을 상속받아 run()메서드를 오버라이딩 해서 필요한 내용을 작성  
Runnable 객체를 Thread 생성자에 파라미터로 넘겨 Thread객체를 생성  
자바 프로세스의 출발점 : main()  
스레드 출발점 : run()
```java
public MyThread1 interface Runnable{
    public abstract void run();
}

Thread t1 = new Thread(new Runnable(){
    public void run(){
        System.out.println("Hello");
    }
});

public static void main(String[] args){
    Thread th1 = new Thread(new MyThread());
    th1.start();
}
```

2) **Thread 클래스 상속**  
Thread 클래스는 Runnable을 구현하고 있어 Thread 클래스만으로 스레드 생성  
Thread 클래스를 상속받아 run()을 오버라이딩해서 로직 구현  
Thread 클래스 상속은 단일 상속의 제약이 있음  
```java
public MyThread2 extends Thread{
    public void run(){
    }
}

public static void main(String[] args){
    MyThread2 th2 = new MyThread2();
    th2.start();
}
```

#### 스레드 실행  
-   run() : 스레드에서 수행할 작업을 정의하는 메서드  
-   start() : 스레드의 run() 메서드가 호출될 수 있도록 준비하는 과정  
  실제로 run()를 호출하는 것은 JVM  
  JVM이 운영체제의 스레드 스케줄러에 의해 가능할 때 스레드의 run()을 호출  
